<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç­–ç•¥å‚æ•°é…ç½® - Aè‚¡å›æµ‹ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .main-content {
            display: grid;
            grid-template-columns: 500px 1fr;
            gap: 30px;
        }

        .left-panel {
            flex-shrink: 0;
        }

        .right-panel {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            position: sticky;
            top: 20px;
            height: fit-content;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .parameter-group {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .parameter-item {
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 20px;
            align-items: center;
            margin-bottom: 20px;
        }

        .parameter-item:last-child {
            margin-bottom: 0;
        }

        .parameter-label {
            display: flex;
            flex-direction: column;
        }

        .param-name {
            font-weight: bold;
            color: #333;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .param-desc {
            font-size: 12px;
            color: #999;
            line-height: 1.4;
        }

        .parameter-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="range"],
        input[type="number"] {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        input[type="range"] {
            padding: 0;
        }

        input[type="number"] {
            width: 100px;
        }

        .param-value-display {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
            font-size: 14px;
        }

        .param-range {
            font-size: 11px;
            color: #999;
            min-width: 150px;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 30px;
        }

        button {
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .btn-danger {
            background: #f5222d;
            color: white;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .btn-info {
            background: #1890ff;
            color: white;
        }

        .btn-info:hover {
            background: #096dd9;
        }

        .message {
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
            display: none;
            font-size: 14px;
        }

        .message.active {
            display: block;
        }

        .message.success {
            background: #e8f5e9;
            color: #2e7d32;
            border-left: 4px solid #4caf50;
        }

        .message.error {
            background: #ffebee;
            color: #c62828;
            border-left: 4px solid #f44336;
        }

        .message.warning {
            background: #fff3e0;
            color: #e65100;
            border-left: 4px solid #ff9800;
        }

        .preset-section {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
        }

        .preset-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .preset-header h3 {
            font-size: 14px;
            color: #333;
        }

        .preset-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .preset-item {
            background: white;
            border: 1px solid #bbdefb;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }

        .preset-item:hover {
            background: #bbdefb;
        }

        .preset-name {
            flex: 1;
            margin-right: 5px;
        }

        .preset-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: #2196f3;
            font-size: 12px;
            padding: 2px 5px;
        }

        .preset-btn:hover {
            color: #1976d2;
        }

        .preset-input-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .preset-input-group input {
            flex: 1;
            padding: 8px;
            border: 1px solid #bbdefb;
            border-radius: 4px;
            font-size: 12px;
        }

        .preset-input-group button {
            padding: 8px 15px;
            font-size: 12px;
        }

        .info-box {
            background: #f5f5f5;
            border-left: 4px solid #666;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
            font-size: 12px;
            color: #666;
            line-height: 1.6;
        }

        .comparison {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .comparison-box {
            background: #fafafa;
            border-radius: 6px;
            padding: 15px;
        }

        .comparison-title {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }

        .comparison-item {
            font-size: 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        .comparison-label {
            color: #999;
        }

        .comparison-value {
            font-weight: bold;
            color: #333;
        }

        @media (max-width: 768px) {
            .parameter-item {
                grid-template-columns: 1fr;
            }

            .parameter-input {
                flex-direction: column;
            }

            input[type="number"] {
                width: 100%;
            }

            .comparison {
                grid-template-columns: 1fr;
            }

            .button-group {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âš™ï¸ ç­–ç•¥å‚æ•°é…ç½®</h1>
            <p>è‡ªå®šä¹‰å›æµ‹ç­–ç•¥å‚æ•° - å®æ—¶è°ƒæ•´ï¼Œç§’çº§å›æµ‹</p>
        </div>

        <div class="content">
            <div class="main-content">
                <!-- å·¦ä¾§é¢æ¿ï¼šå‚æ•°é…ç½® -->
                <div class="left-panel">
                    <!-- ç­–ç•¥é€‰æ‹©åŒº -->
                    <div class="section">
                        <div class="section-title">ğŸ¯ ç­–ç•¥é€‰æ‹©</div>

                        <div class="parameter-group">
                            <div class="parameter-item">
                                <div class="parameter-label">
                                    <div class="param-name">å›æµ‹ç­–ç•¥</div>
                                    <div class="param-desc">é€‰æ‹©è¦é…ç½®çš„å›æµ‹ç­–ç•¥</div>
                                </div>
                                <div class="parameter-input">
                                    <select id="strategySelect" onchange="switchStrategy()"
                                            style="flex: 1; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 14px;">
                                        <option value="">åŠ è½½ä¸­...</option>
                                    </select>
                                </div>
                            </div>

                            <div id="strategyDescription" style="background: #f0f7ff; padding: 12px; border-radius: 6px; font-size: 13px; color: #666; margin-top: 10px;">
                                è¯·é€‰æ‹©ç­–ç•¥
                            </div>
                        </div>
                    </div>

                    <!-- å‚æ•°é…ç½®åŒº -->
                    <div class="section">
                        <div class="section-title">ğŸ“Š ç­–ç•¥å‚æ•°</div>

                        <div class="parameter-group" id="parametersContainer">
                            <!-- åŠ¨æ€ç”Ÿæˆå‚æ•°è¾“å…¥ -->
                        </div>

                        <div class="button-group">
                            <button class="btn-primary" onclick="saveParameters()">ğŸ’¾ ä¿å­˜å‚æ•°</button>
                            <button class="btn-secondary" onclick="resetToDefault()">ğŸ”„ æ¢å¤é»˜è®¤</button>
                            <button class="btn-info" onclick="reloadPage()">ğŸ”ƒ åˆ·æ–°é¡µé¢</button>
                            <button class="btn-secondary" onclick="goBackToBacktest()">ğŸ  è¿”å›å›æµ‹</button>
                            <button class="btn-secondary" onclick="regenerateKLine()">ğŸ² é‡æ–°ç”ŸæˆKçº¿</button>
                        </div>

                        <div id="paramMessage" class="message"></div>
                    </div>

                    <!-- å‚æ•°å¯¹æ¯”åŒº -->
                    <div class="section">
                        <div class="section-title">ğŸ“ˆ å‚æ•°å¯¹æ¯”</div>

                        <div class="comparison">
                            <div class="comparison-box">
                                <div class="comparison-title">å½“å‰å‚æ•°</div>
                                <div id="currentParams"></div>
                            </div>

                            <div class="comparison-box">
                                <div class="comparison-title">é»˜è®¤å‚æ•°</div>
                                <div id="defaultParams"></div>
                            </div>
                        </div>
                    </div>

                    <!-- é¢„è®¾ç®¡ç†åŒº -->
                    <div class="section">
                        <div class="section-title">ğŸ’¾ å‚æ•°é¢„è®¾</div>

                        <div class="preset-section">
                            <div class="preset-header">
                                <h3>ğŸ¯ ä¿å­˜çš„é¢„è®¾</h3>
                                <span id="presetCount" style="font-size: 12px; color: #999;"></span>
                            </div>

                            <div class="preset-list" id="presetList">
                                <!-- åŠ¨æ€ç”Ÿæˆé¢„è®¾åˆ—è¡¨ -->
                            </div>

                            <div class="preset-input-group">
                                <input type="text" id="presetName" placeholder="è¾“å…¥é¢„è®¾åç§°">
                                <button class="btn-info" onclick="savePreset()">ğŸ’¾ ä¿å­˜å½“å‰ä¸ºé¢„è®¾</button>
                            </div>

                            <div id="presetMessage" class="message"></div>
                        </div>
                    </div>

                    <!-- æç¤ºä¿¡æ¯ -->
                    <div class="info-box">
                        <strong>ğŸ’¡ ä½¿ç”¨æç¤ºï¼š</strong><br>
                        â€¢ å‚æ•°ä¿®æ”¹åç‚¹å‡»"ä¿å­˜å‚æ•°"æŒ‰é’®<br>
                        â€¢ ä¿®æ”¹åçš„å‚æ•°ä¼šç«‹å³åº”ç”¨åˆ°å›æµ‹<br>
                        â€¢ å¯ä»¥ä¿å­˜å¸¸ç”¨çš„å‚æ•°ç»„åˆä¸ºé¢„è®¾<br>
                        â€¢ ç‚¹å‡»é¢„è®¾åç§°å¿«é€ŸåŠ è½½é¢„è®¾<br>
                        â€¢ æ‹–åŠ¨æ»‘å—æˆ–ç›´æ¥è¾“å…¥æ•°å­—ä¿®æ”¹å‚æ•°
                    </div>
                </div>

                <!-- å³ä¾§é¢æ¿ï¼šå›¾ç¤ºé¢„è§ˆ -->
                <div class="right-panel">
                    <div class="section-title" style="margin-bottom: 15px;">ğŸ“ˆ ä¿¡å·é¢„è§ˆ</div>

                    <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="font-size: 13px; color: #666; margin-bottom: 10px;">
                            <strong>è¯´æ˜ï¼š</strong>æ ¹æ®å½“å‰å‚æ•°æ¨¡æ‹Ÿä¿¡å·
                        </div>

                        <!-- Kçº¿å›¾ç¤ºåŒºåŸŸ -->
                        <canvas id="signalChart" width="600" height="400" style="width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;"></canvas>
                    </div>

                    <!-- å›¾ä¾‹è¯´æ˜ -->
                    <div style="background: white; padding: 12px; border-radius: 8px; font-size: 12px;">
                        <div style="margin-bottom: 8px;">
                            <span style="color: #f44336;">â–²</span> <strong>ä¹°å…¥ä¿¡å·</strong> - æ»¡è¶³æ‰€æœ‰ä¹°å…¥æ¡ä»¶
                        </div>
                        <div style="margin-bottom: 8px;">
                            <span style="color: #4caf50;">â–¼</span> <strong>å–å‡ºä¿¡å·</strong> - è¾¾åˆ°æŒæœ‰å¤©æ•°
                        </div>
                        <div style="margin-bottom: 8px;">
                            <span style="color: #ff9800;">â”â”</span> <strong>å‡çº¿</strong> - è¶‹åŠ¿åˆ¤æ–­åŸºå‡†
                        </div>
                        <div>
                            <span style="color: #2196f3;">â”â”</span> <strong>å›è¸©çº¿</strong> - çŸ­æœŸæ”¯æ’‘
                        </div>
                    </div>
                </div>
            </div>
        </div>

    <script>
        // ä½¿ç”¨windowå¯¹è±¡ç¡®ä¿å…¨å±€å¯è®¿é—®
        window.currentParams = {};
        window.defaultParams = {};
        window.currentStrategy = '';
        window.allStrategies = [];
        window.cachedKLineData = null;  // âœ… æ–°å¢ï¼šç¼“å­˜Kçº¿æ•°æ®

        // é¡µé¢åŠ è½½æ—¶è·å–å‚æ•°
        window.addEventListener('load', async () => {
            await loadStrategies();
            await loadParameterInfo();
            renderParameters();
            renderComparison();
            loadPresets();

            // ç»˜åˆ¶åˆå§‹å›¾è¡¨
            setTimeout(() => {
                drawKLineChart();
            }, 800);
        });

        // åŠ è½½æ‰€æœ‰ç­–ç•¥åˆ—è¡¨
        async function loadStrategies() {
            try {
                const response = await fetch('/api/strategies');
                const result = response.json ? await response.json() : JSON.parse(response.data);

                if (result.success) {
                    window.allStrategies = result.strategies;
                    window.currentStrategy = result.current_strategy;

                    // å¡«å……ä¸‹æ‹‰æ¡†
                    const select = document.getElementById('strategySelect');
                    select.innerHTML = '';

                    result.strategies.forEach(strategy => {
                        const option = document.createElement('option');
                        option.value = strategy.key;
                        option.textContent = strategy.name;
                        if (strategy.key === window.currentStrategy) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    });

                    // æ˜¾ç¤ºå½“å‰ç­–ç•¥æè¿°
                    updateStrategyDescription();
                } else {
                    showMessage('paramMessage', 'åŠ è½½ç­–ç•¥å¤±è´¥: ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('paramMessage', 'åŠ è½½ç­–ç•¥é”™è¯¯: ' + error.message, 'error');
                console.error('åŠ è½½ç­–ç•¥å¼‚å¸¸:', error);
            }
        }

        // æ›´æ–°ç­–ç•¥æè¿°
        function updateStrategyDescription() {
            const strategy = window.allStrategies.find(s => s.key === window.currentStrategy);
            if (strategy) {
                document.getElementById('strategyDescription').innerHTML =
                    `<strong>${strategy.name}</strong><br>${strategy.description}`;
            }
        }

        // åˆ‡æ¢ç­–ç•¥
        async function switchStrategy() {
            const select = document.getElementById('strategySelect');
            const newStrategy = select.value;

            if (newStrategy === window.currentStrategy) {
                return;
            }

            if (!confirm(`ç¡®å®šåˆ‡æ¢åˆ°ç­–ç•¥: ${select.options[select.selectedIndex].text}ï¼Ÿ`)) {
                select.value = window.currentStrategy;
                return;
            }

            try {
                showMessage('paramMessage', 'æ­£åœ¨åˆ‡æ¢ç­–ç•¥...', 'warning');

                const response = await fetch('/api/strategies/current', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({strategy: newStrategy})
                });

                const result = await response.json();

                if (result.success) {
                    window.currentStrategy = newStrategy;
                    updateStrategyDescription();

                    // é‡æ–°åŠ è½½å‚æ•°
                    await loadParameterInfo();
                    renderParameters();
                    renderComparison();

                    // âœ… æ–°å¢ï¼šæ¸…ç©ºKçº¿ç¼“å­˜ï¼Œä¸‹æ¬¡ç»˜åˆ¶æ—¶é‡æ–°ç”Ÿæˆ
                    window.cachedKLineData = null;

                    // é‡æ–°ç»˜åˆ¶å›¾è¡¨ï¼ˆå¯èƒ½æ˜¾ç¤ºä¸æ”¯æŒçš„æç¤ºï¼‰
                    setTimeout(() => {
                        if (typeof drawKLineChart === 'function') {
                            drawKLineChart();
                        }
                    }, 500);

                    showMessage('paramMessage', result.message, 'success');
                } else {
                    showMessage('paramMessage', result.error || 'åˆ‡æ¢å¤±è´¥', 'error');
                    select.value = window.currentStrategy;
                }
            } catch (error) {
                showMessage('paramMessage', 'åˆ‡æ¢ç­–ç•¥å¤±è´¥: ' + error.message, 'error');
                select.value = window.currentStrategy;
            }
        }

        // åŠ è½½å‚æ•°ä¿¡æ¯
        async function loadParameterInfo() {
            try {
                const response = await fetch('/api/parameters');
                const result = await response.json();

                if (result.success) {
                    const info = result.data;
                    window.currentParams = info.current_params;
                    window.defaultParams = info.default_params;
                } else {
                    showMessage('paramMessage', 'åŠ è½½å‚æ•°å¤±è´¥: ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('paramMessage', 'ç½‘ç»œé”™è¯¯: ' + error.message, 'error');
            }
        }

        // æ¸²æŸ“å‚æ•°è¾“å…¥
        function renderParameters() {
            const container = document.getElementById('parametersContainer');

            // ä¸ºæ‰€æœ‰å¯èƒ½çš„å‚æ•°å®šä¹‰èŒƒå›´å’Œæè¿°
            const ranges = {
                // åŸæœ‰ç­–ç•¥å‚æ•°
                'ma_period': {min: 5, max: 250, step: 1},
                'volume_multiplier': {min: 0.5, max: 10, step: 0.1},
                'retest_period': {min: 3, max: 20, step: 1},
                'hold_days': {min: 1, max: 10, step: 1},
                'recent_days': {min: 1, max: 20, step: 1},
                'turnover_min': {min: 0.01, max: 1000, step: 1},
                'turnover_max': {min: 0.01, max: 1000, step: 1},

                // ç¨³å¥å‹è¶‹åŠ¿ç­–ç•¥å‚æ•°
                'ma_short': {min: 5, max: 100, step: 1},
                'ma_long': {min: 10, max: 200, step: 1},
                'ma_filter': {min: 20, max: 300, step: 1},
                'volume_ma': {min: 5, max: 50, step: 1},
                'macd_fast': {min: 5, max: 20, step: 1},
                'macd_slow': {min: 15, max: 50, step: 1},
                'macd_signal': {min: 5, max: 20, step: 1},
                'stop_loss': {min: 0.01, max: 0.3, step: 0.01},
                'take_profit': {min: 0.05, max: 0.5, step: 0.05},
                'trailing_stop': {min: 0.01, max: 0.2, step: 0.01},
                'position_size': {min: 0.01, max: 1, step: 0.05},

                // æ¿€è¿›å‹åŠ¨é‡ç­–ç•¥å‚æ•°
                'breakout_period': {min: 5, max: 50, step: 1},
                'breakout_threshold': {min: 0.01, max: 0.2, step: 0.01},
                'rsi_period': {min: 2, max: 20, step: 1},
                'rsi_threshold': {min: 30, max: 70, step: 5},
                'kdj_n': {min: 2, max: 20, step: 1},
                'kdj_m1': {min: 1, max: 10, step: 1},
                'kdj_m2': {min: 1, max: 10, step: 1},
                'atr_period': {min: 5, max: 30, step: 1},
                'atr_stop_mult': {min: 0.5, max: 5, step: 0.5},
                'max_hold_days': {min: 1, max: 20, step: 1},

                // å¹³è¡¡å‹å¤šå› å­ç­–ç•¥å‚æ•°
                'boll_period': {min: 10, max: 50, step: 1},
                'boll_std': {min: 0.5, max: 4, step: 0.5},
                'rsi_oversold': {min: 10, max: 50, step: 5},
                'rsi_overbought': {min: 50, max: 90, step: 5},
                'take_profit_1': {min: 0.02, max: 0.2, step: 0.01},
                'take_profit_2': {min: 0.05, max: 0.3, step: 0.01},
                'take_profit_final': {min: 0.1, max: 0.5, step: 0.05},
                'factor_weight_boll': {min: 0, max: 1, step: 0.05},
                'factor_weight_rsi': {min: 0, max: 1, step: 0.05},
                'factor_weight_macd': {min: 0, max: 1, step: 0.05},
                'factor_weight_volume': {min: 0, max: 1, step: 0.05},
                'factor_weight_price': {min: 0, max: 1, step: 0.05},
                'min_factor_score': {min: 0.3, max: 1, step: 0.05}
            };

            const descriptions = {
                // åŸæœ‰ç­–ç•¥
                'ma_period': '30æ—¥å‡çº¿å‘¨æœŸï¼ˆå¤©ï¼‰ï¼Œç”¨äºåˆ¤æ–­ä¸Šå‡è¶‹åŠ¿',
                'volume_multiplier': 'é‡èƒ½å€æ•°ï¼Œæœ€è¿‘3æ—¥æ€»é‡èƒ½ vs 20æ—¥å‡é‡èƒ½ * å€æ•°',
                'retest_period': '5æ—¥çº¿å‘¨æœŸï¼ˆå¤©ï¼‰ï¼Œç”¨äºæ£€æµ‹ä»·æ ¼å›è¸©',
                'hold_days': 'æŒæœ‰å¤©æ•°ï¼ˆäº¤æ˜“æ—¥ï¼‰ï¼Œä¹°å…¥åNå¤©å–å‡º',
                'recent_days': 'å‚è€ƒå€¼',
                'turnover_min': 'ä¸Šä¸€äº¤æ˜“æ—¥æˆäº¤é‡‘é¢æœ€å°å€¼ï¼ˆäº¿å…ƒï¼‰ï¼Œä½äºæ­¤å€¼ä¸äº¤æ˜“',
                'turnover_max': 'ä¸Šä¸€äº¤æ˜“æ—¥æˆäº¤é‡‘é¢æœ€å¤§å€¼ï¼ˆäº¿å…ƒï¼‰ï¼Œè¶…è¿‡æ­¤å€¼ä¸äº¤æ˜“',

                // ç¨³å¥å‹è¶‹åŠ¿ç­–ç•¥
                'ma_short': 'çŸ­æœŸå‡çº¿å‘¨æœŸ',
                'ma_long': 'é•¿æœŸå‡çº¿å‘¨æœŸ',
                'ma_filter': 'è¶‹åŠ¿æ»¤æ³¢å‡çº¿å‘¨æœŸ',
                'volume_ma': 'æˆäº¤é‡å‡çº¿å‘¨æœŸ',
                'macd_fast': 'MACDå¿«çº¿å‘¨æœŸ',
                'macd_slow': 'MACDæ…¢çº¿å‘¨æœŸ',
                'macd_signal': 'MACDä¿¡å·çº¿å‘¨æœŸ',
                'stop_loss': 'æ­¢æŸå¹…åº¦æ¯”ä¾‹',
                'take_profit': 'æ­¢ç›ˆå¹…åº¦æ¯”ä¾‹',
                'trailing_stop': 'ç§»åŠ¨æ­¢ç›ˆå¹…åº¦æ¯”ä¾‹',
                'position_size': 'å•æ¬¡ä»“ä½å¤§å°',

                // æ¿€è¿›å‹åŠ¨é‡ç­–ç•¥
                'breakout_period': 'çªç ´å‘¨æœŸï¼ˆå¤©ï¼‰',
                'breakout_threshold': 'çªç ´å¹…åº¦é˜ˆå€¼',
                'rsi_period': 'RSIè®¡ç®—å‘¨æœŸ',
                'rsi_threshold': 'RSIå¼ºåŠ¿çº¿ï¼ˆ>è¡¨ç¤ºå¼ºåŠ¿ï¼‰',
                'kdj_n': 'KDJè®¡ç®—å‘¨æœŸ',
                'kdj_m1': 'KDJå¹³æ»‘å‚æ•°1',
                'kdj_m2': 'KDJå¹³æ»‘å‚æ•°2',
                'atr_period': 'ATRè®¡ç®—å‘¨æœŸ',
                'atr_stop_mult': 'ATRæ­¢æŸå€æ•°',
                'max_hold_days': 'æœ€å¤§æŒä»“å¤©æ•°',

                // å¹³è¡¡å‹å¤šå› å­ç­–ç•¥
                'boll_period': 'å¸ƒæ—å¸¦å‘¨æœŸ',
                'boll_std': 'å¸ƒæ—å¸¦æ ‡å‡†å·®å€æ•°',
                'rsi_oversold': 'RSIè¶…å–çº¿',
                'rsi_overbought': 'RSIè¶…ä¹°çº¿',
                'take_profit_1': 'ç¬¬ä¸€æ‰¹æ­¢ç›ˆå¹…åº¦',
                'take_profit_2': 'ç¬¬äºŒæ‰¹æ­¢ç›ˆå¹…åº¦',
                'take_profit_final': 'æœ€ç»ˆæ­¢ç›ˆå¹…åº¦',
                'factor_weight_boll': 'å¸ƒæ—å¸¦å› å­æƒé‡',
                'factor_weight_rsi': 'RSIå› å­æƒé‡',
                'factor_weight_macd': 'MACDå› å­æƒé‡',
                'factor_weight_volume': 'æˆäº¤é‡å› å­æƒé‡',
                'factor_weight_price': 'ä»·æ ¼å› å­æƒé‡',
                'min_factor_score': 'æœ€ä½å› å­è¯„åˆ†é˜ˆå€¼'
            };

            container.innerHTML = '';

            for (const [key, value] of Object.entries(window.currentParams)) {
                const range = ranges[key] || {min: 0, max: 100, step: 1};
                const desc = descriptions[key] || key;

                const html = `
                    <div class="parameter-item">
                        <div class="parameter-label">
                            <div class="param-name">${key}</div>
                            <div class="param-desc">${desc}</div>
                        </div>
                        <div class="parameter-input">
                            <input type="range" id="range_${key}"
                                   min="${range.min}" max="${range.max}" step="${range.step}"
                                   value="${value}" onchange="updateValue('${key}')" oninput="updateValue('${key}')">
                            <input type="number" id="number_${key}"
                                   min="${range.min}" max="${range.max}" step="${range.step}"
                                   value="${value}" onchange="updateValue('${key}')" oninput="updateValue('${key}')">
                            <div class="param-value-display" id="display_${key}">${value}</div>
                            <div class="param-range">${range.min} ~ ${range.max}</div>
                        </div>
                    </div>
                `;

                container.innerHTML += html;
            }
        }

        // æ›´æ–°å‚æ•°å€¼
        function updateValue(paramName) {
            const rangeInput = document.getElementById(`range_${paramName}`);
            const numberInput = document.getElementById(`number_${paramName}`);
            const display = document.getElementById(`display_${paramName}`);

            // åŒæ­¥ä¸¤ä¸ªè¾“å…¥æ¡†
            let value = rangeInput.value;
            numberInput.value = value;

            window.currentParams[paramName] = parseFloat(value);
            display.textContent = value;

            // å®æ—¶æ›´æ–°å›¾è¡¨ï¼ˆé˜²æŠ–ï¼‰
            clearTimeout(window.chartUpdateTimer);
            window.chartUpdateTimer = setTimeout(() => {
                if (typeof drawKLineChart === 'function') {
                    drawKLineChart();
                }
            }, 300);
        }

        // ä¿å­˜å‚æ•°
        async function saveParameters() {
            try {
                const response = await fetch('/api/parameters/update', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({params: window.currentParams})
                });

                const result = await response.json();

                if (result.success) {
                    window.currentParams = result.new_params;
                    renderComparison();
                    showMessage('paramMessage', 'âœ“ å‚æ•°å·²ä¿å­˜ï¼Œå°†åº”ç”¨åˆ°ä¸‹æ¬¡å›æµ‹', 'success');
                } else {
                    showMessage('paramMessage', 'âœ— ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('paramMessage', 'âœ— ç½‘ç»œé”™è¯¯: ' + error.message, 'error');
            }
        }

        // æ¢å¤é»˜è®¤
        async function resetToDefault() {
            if (!confirm('ç¡®å®šè¦æ¢å¤ä¸ºé»˜è®¤å‚æ•°å—?')) return;

            try {
                const response = await fetch('/api/parameters/reset', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({})
                });

                const result = await response.json();

                if (result.success) {
                    window.currentParams = result.new_params;
                    renderParameters();
                    renderComparison();
                    showMessage('paramMessage', 'âœ“ å·²æ¢å¤ä¸ºé»˜è®¤å‚æ•°', 'success');
                } else {
                    showMessage('paramMessage', 'âœ— ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('paramMessage', 'âœ— ç½‘ç»œé”™è¯¯: ' + error.message, 'error');
            }
        }

        // æ¸²æŸ“å‚æ•°å¯¹æ¯”
        function renderComparison() {
            const currentHTML = Object.entries(window.currentParams).map(([key, value]) => `
                <div class="comparison-item">
                    <span class="comparison-label">${key}</span>
                    <span class="comparison-value">${value}</span>
                </div>
            `).join('');

            const defaultHTML = Object.entries(window.defaultParams).map(([key, value]) => `
                <div class="comparison-item">
                    <span class="comparison-label">${key}</span>
                    <span class="comparison-value">${value}</span>
                </div>
            `).join('');

            document.getElementById('currentParams').innerHTML = currentHTML;
            document.getElementById('defaultParams').innerHTML = defaultHTML;
        }

        // ä¿å­˜é¢„è®¾
        async function savePreset() {
            const presetName = document.getElementById('presetName').value.trim();

            if (!presetName) {
                showMessage('presetMessage', 'âœ— è¯·è¾“å…¥é¢„è®¾åç§°', 'error');
                return;
            }

            try {
                const response = await fetch('/api/parameters/preset', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action: 'save',
                        name: presetName
                    })
                });

                const result = await response.json();

                if (result.success) {
                    document.getElementById('presetName').value = '';
                    loadPresets();
                    showMessage('presetMessage', result.message, 'success');
                } else {
                    showMessage('presetMessage', 'âœ— ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('presetMessage', 'âœ— ç½‘ç»œé”™è¯¯: ' + error.message, 'error');
            }
        }

        // åŠ è½½é¢„è®¾åˆ—è¡¨
        async function loadPresets() {
            try {
                const response = await fetch('/api/parameters/preset');
                const result = await response.json();

                if (result.success) {
                    const presets = result.presets;
                    const presetList = document.getElementById('presetList');

                    if (Object.keys(presets).length === 0) {
                        presetList.innerHTML = '<p style="color: #999; font-size: 12px;">æš‚æ— é¢„è®¾</p>';
                        document.getElementById('presetCount').textContent = '0ä¸ªé¢„è®¾';
                    } else {
                        presetList.innerHTML = Object.keys(presets).map(name => `
                            <div class="preset-item">
                                <span class="preset-name" onclick="loadPreset('${name}')" title="ç‚¹å‡»åŠ è½½">${name}</span>
                                <button class="preset-btn" onclick="deletePreset('${name}')" title="åˆ é™¤">âœ•</button>
                            </div>
                        `).join('');
                        document.getElementById('presetCount').textContent = Object.keys(presets).length + 'ä¸ªé¢„è®¾';
                    }
                }
            } catch (error) {
                console.error('åŠ è½½é¢„è®¾å¤±è´¥:', error);
            }
        }

        // åŠ è½½é¢„è®¾
        async function loadPreset(presetName) {
            try {
                const response = await fetch('/api/parameters/preset', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action: 'load',
                        name: presetName
                    })
                });

                const result = await response.json();

                if (result.success) {
                    window.currentParams = result.new_params;
                    renderParameters();
                    renderComparison();
                    showMessage('presetMessage', result.message, 'success');
                } else {
                    showMessage('presetMessage', 'âœ— ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('presetMessage', 'âœ— ç½‘ç»œé”™è¯¯: ' + error.message, 'error');
            }
        }

        // åˆ é™¤é¢„è®¾
        async function deletePreset(presetName) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤é¢„è®¾ "${presetName}" å—?`)) return;

            try {
                const response = await fetch('/api/parameters/preset', {
                    method: 'DELETE',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({name: presetName})
                });

                const result = await response.json();

                if (result.success) {
                    loadPresets();
                    showMessage('presetMessage', result.message, 'success');
                } else {
                    showMessage('presetMessage', 'âœ— ' + result.error, 'error');
                }
            } catch (error) {
                showMessage('presetMessage', 'âœ— ç½‘ç»œé”™è¯¯: ' + error.message, 'error');
            }
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(elementId, message, type) {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.className = `message active ${type}`;

            setTimeout(() => {
                el.classList.remove('active');
            }, 5000);
        }

        // åˆ·æ–°é¡µé¢
        function reloadPage() {
            location.reload();
        }

        // è¿”å›å›æµ‹é¡µé¢
        function goBackToBacktest() {
            window.location.href = '/';
        }

        // é‡æ–°ç”ŸæˆKçº¿æ•°æ®
        function regenerateKLine() {
            window.cachedKLineData = null;
            if (typeof drawKLineChart === 'function') {
                drawKLineChart();
            }
            showMessage('paramMessage', 'âœ“ Kçº¿æ•°æ®å·²é‡æ–°ç”Ÿæˆ', 'success');
        }

        // ==================== Kçº¿å›¾ç¤ºåŠŸèƒ½ ====================

        // ç”Ÿæˆæ¨¡æ‹ŸKçº¿æ•°æ®
        function generateMockKLineData(days = 60) {
            const data = [];
            let price = 10 + Math.random() * 5;
            const baseDate = new Date();
            baseDate.setDate(baseDate.getDate() - days);

            for (let i = 0; i < days; i++) {
                const date = new Date(baseDate);
                date.setDate(date.getDate() + i);

                // æ¨¡æ‹Ÿä»·æ ¼æ³¢åŠ¨
                const change = (Math.random() - 0.48) * 0.5;
                price = price * (1 + change);

                const open = price;
                const high = price * (1 + Math.random() * 0.03);
                const low = price * (1 - Math.random() * 0.03);
                const close = low + (high - low) * Math.random();
                const volume = (50 + Math.random() * 100) * 10000;

                data.push({
                    date: date.toISOString().split('T')[0],
                    open: open,
                    high: high,
                    low: low,
                    close: close,
                    volume: volume
                });
            }

            return data;
        }

        // è®¡ç®—å‡çº¿
        function calculateMA(data, period) {
            const ma = [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    ma.push(null);
                } else {
                    let sum = 0;
                    for (let j = 0; j < period; j++) {
                        sum += data[i - j].close;
                    }
                    ma.push(sum / period);
                }
            }
            return ma;
        }

        // è®¡ç®—æˆäº¤é‡å‡çº¿
        function calculateVolumeMA(data, period) {
            const ma = [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    ma.push(null);
                } else {
                    let sum = 0;
                    for (let j = 0; j < period; j++) {
                        sum += data[i - j].volume;
                    }
                    ma.push(sum / period);
                }
            }
            return ma;
        }

        // æ£€æµ‹ä¹°å…¥ä¿¡å·
        function detectBuySignals(data, params) {
            const signals = [];
            const ma = calculateMA(data, params.ma_period || 30);
            const retestMA = calculateMA(data, params.retest_period || 5);
            const volumeMA = calculateVolumeMA(data, 20);

            for (let i = Math.max(params.ma_period || 30, 20); i < data.length; i++) {
                // ä¹°å…¥æ¡ä»¶ï¼ˆç®€åŒ–ç‰ˆï¼Œä¾¿äºå¯è§†åŒ–ï¼‰ï¼š
                // 1. ä»·æ ¼åœ¨é•¿æœŸå‡çº¿ä¸Šæ–¹ï¼ˆè¶‹åŠ¿å‘ä¸Šï¼‰
                // 2. ä»·æ ¼æ¥è¿‘çŸ­æœŸå‡çº¿ï¼ˆå›è¸©æœºä¼šï¼ŒèŒƒå›´Â±8%ï¼‰
                // 3. æˆäº¤é‡æ”¾å¤§ï¼ˆæœ€è¿‘3å¤© vs 1å¤©å‡é‡ï¼‰
                const priceAboveMA = data[i].close > ma[i];
                const nearRetestMA = Math.abs(data[i].close - retestMA[i]) / retestMA[i] < 0.08;

                // è®¡ç®—æœ€è¿‘3å¤©æ€»é‡èƒ½
                let recentVolume = 0;
                for (let j = 0; j < 3 && i - j >= 0; j++) {
                    recentVolume += data[i - j].volume;
                }
                // ç®€åŒ–é‡èƒ½æ¡ä»¶ï¼šæœ€è¿‘3å¤©æ€»é‡ vs 1å¤©å‡é‡ Ã— é‡èƒ½å€æ•°
                const volumeSpike = recentVolume > (volumeMA[i] * (params.volume_multiplier || 2));

                if (priceAboveMA && nearRetestMA && volumeSpike) {
                    signals.push({
                        index: i,
                        type: 'buy',
                        price: data[i].close
                    });
                }
            }

            return signals;
        }

        // ç»˜åˆ¶Kçº¿å›¾
        function drawKLineChart() {
            const canvas = document.getElementById('signalChart');
            if (!canvas || !canvas.getContext) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);

            // æ£€æŸ¥å½“å‰ç­–ç•¥æ˜¯å¦æ”¯æŒå›¾è¡¨é¢„è§ˆ
            const supportedStrategies = ['volume_breakout'];
            const currentStrategy = window.currentStrategy || '';

            if (!supportedStrategies.includes(currentStrategy)) {
                // æ˜¾ç¤ºæç¤ºä¿¡æ¯
                ctx.fillStyle = '#666';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('å½“å‰ç­–ç•¥æš‚ä¸æ”¯æŒå›¾è¡¨é¢„è§ˆ', width / 2, height / 2 - 20);
                ctx.font = '14px Arial';
                ctx.fillStyle = '#999';
                ctx.fillText('ä»…"é‡èƒ½çªç ´å›è¸©ç­–ç•¥"æ”¯æŒä¿¡å·å¯è§†åŒ–', width / 2, height / 2 + 10);
                return;
            }

            // ç”Ÿæˆæ•°æ®ï¼ˆåªåœ¨ç¬¬ä¸€æ¬¡æˆ–ç¼“å­˜ä¸ºç©ºæ—¶ç”Ÿæˆæ•°æ®ï¼‰
            // å‡å°‘Kçº¿æ•°é‡åˆ°40æ ¹ï¼Œè®©æ¯æ ¹Kçº¿æ›´å®½æ›´æ˜æ˜¾
            if (!window.cachedKLineData) {
                window.cachedKLineData = generateMockKLineData(40);
            }
            const data = window.cachedKLineData;
            const params = window.currentParams || {};

            // è®¡ç®—æŒ‡æ ‡
            const ma = calculateMA(data, params.ma_period || 30);
            const retestMA = calculateMA(data, params.retest_period || 5);
            const buySignals = detectBuySignals(data, params);

            // è®¡ç®—å–å‡ºä¿¡å·ï¼ˆä¹°å…¥åNå¤©ï¼‰
            const sellSignals = buySignals.map(signal => ({
                index: Math.min(signal.index + (params.hold_days || 5), data.length - 1),
                type: 'sell',
                price: data[Math.min(signal.index + (params.hold_days || 5), data.length - 1)].close,
                buyIndex: signal.index
            }));

            // è®¡ç®—ä»·æ ¼èŒƒå›´
            const prices = data.map(d => [d.high, d.low]).flat();
            const maxPrice = Math.max(...prices);
            const minPrice = Math.min(...prices);
            const priceRange = maxPrice - minPrice;

            // å›¾è¡¨åŒºåŸŸåˆ’åˆ†
            const chartHeight = height * 0.7;  // 70% for price
            const volumeHeight = height * 0.25; // 25% for volume
            const padding = 40;

            // è®¡ç®—Xè½´æ¯æ ¹Kçº¿çš„å®½åº¦
            const barWidth = (width - padding * 2) / data.length;
            const candleWidth = barWidth * 0.8;  // å¢åŠ åˆ°0.8ï¼Œè®©Kçº¿æ›´å®½æ›´æ˜æ˜¾

            // è¾…åŠ©å‡½æ•°ï¼šä»·æ ¼è½¬Yåæ ‡
            function priceToY(price) {
                return padding + (maxPrice - price) / priceRange * (chartHeight - padding);
            }

            // è¾…åŠ©å‡½æ•°ï¼šæˆäº¤é‡è½¬é«˜åº¦
            const maxVolume = Math.max(...data.map(d => d.volume));
            function volumeToHeight(volume) {
                return (volume / maxVolume) * volumeHeight;
            }

            // 1. ç»˜åˆ¶èƒŒæ™¯ç½‘æ ¼
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = 0; i < 5; i++) {
                const y = padding + (chartHeight - padding) * i / 4;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }

            // 2. ç»˜åˆ¶Kçº¿ï¼ˆå®ä½“æŸ±çŠ¶å›¾ï¼šä»æœ€ä½ä»·åˆ°æœ€é«˜ä»·çš„å®Œæ•´æŸ±å­ï¼‰
            data.forEach((d, i) => {
                const x = padding + i * barWidth + barWidth / 2;
                const isRed = d.close > d.open;  // ä¸­å›½ä¹ æƒ¯ï¼šçº¢æ¶¨ç»¿è·Œ

                // ç»˜åˆ¶ä»æœ€ä½ä»·åˆ°æœ€é«˜ä»·çš„å®Œæ•´æŸ±å­
                const top = priceToY(d.high);
                const bottom = priceToY(d.low);
                const barHeight = bottom - top;

                ctx.fillStyle = isRed ? '#e53935' : '#43a047';
                ctx.fillRect(x - candleWidth / 2, top, candleWidth, Math.max(barHeight, 2));
            });

            // 3. ç»˜åˆ¶å‡çº¿
            if (ma.length > 0) {
                ctx.strokeStyle = '#ff9800';
                ctx.lineWidth = 2;
                ctx.beginPath();
                let started = false;
                ma.forEach((m, i) => {
                    if (m !== null) {
                        const x = padding + i * barWidth + barWidth / 2;
                        const y = priceToY(m);
                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                });
                ctx.stroke();
            }

            // 4. ç»˜åˆ¶å›è¸©å‡çº¿
            if (retestMA.length > 0) {
                ctx.strokeStyle = '#2196f3';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                let started = false;
                retestMA.forEach((m, i) => {
                    if (m !== null) {
                        const x = padding + i * barWidth + barWidth / 2;
                        const y = priceToY(m);
                        if (!started) {
                            ctx.moveTo(x, y);
                            started = true;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                });
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // 5. ç»˜åˆ¶æˆäº¤é‡ï¼ˆå¢åŠ é€æ˜åº¦å’Œå®½åº¦ï¼‰
            const volumeBaseY = chartHeight + 20;
            data.forEach((d, i) => {
                const x = padding + i * barWidth + barWidth / 2;
                const h = volumeToHeight(d.volume);
                const isRed = d.close > d.open;

                // ä½¿ç”¨æ›´é«˜çš„ä¸é€æ˜åº¦ï¼ˆ0.8ï¼‰è®©æˆäº¤é‡æ›´æ˜æ˜¾
                ctx.fillStyle = isRed ? 'rgba(229, 57, 53, 0.8)' : 'rgba(67, 160, 71, 0.8)';
                ctx.fillRect(x - candleWidth / 2, volumeBaseY + volumeHeight - h, candleWidth, h);
            });

            // 6. ç»˜åˆ¶ä¹°å…¥ä¿¡å·
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            buySignals.forEach(signal => {
                const x = padding + signal.index * barWidth + barWidth / 2;
                const y = priceToY(signal.price) - 15;

                ctx.fillStyle = '#f44336';
                ctx.fillText('â–²', x, y);
            });

            // 7. ç»˜åˆ¶å–å‡ºä¿¡å·
            sellSignals.forEach(signal => {
                const x = padding + signal.index * barWidth + barWidth / 2;
                const y = priceToY(signal.price) + 20;

                ctx.fillStyle = '#4caf50';
                ctx.fillText('â–¼', x, y);

                // è¿çº¿æ˜¾ç¤ºæŒæœ‰æœŸ
                const buyX = padding + signal.buyIndex * barWidth + barWidth / 2;
                const buyY = priceToY(data[signal.buyIndex].close);

                ctx.strokeStyle = 'rgba(255, 152, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(buyX, buyY);
                ctx.lineTo(x, priceToY(signal.price));
                ctx.stroke();
            });

            // 8. ç»˜åˆ¶åæ ‡è½´æ ‡ç­¾
            ctx.fillStyle = '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'right';

            // Yè½´ä»·æ ¼æ ‡ç­¾
            for (let i = 0; i < 5; i++) {
                const price = maxPrice - (priceRange * i / 4);
                const y = padding + (chartHeight - padding) * i / 4;
                ctx.fillText(price.toFixed(2), padding - 5, y + 4);
            }

            // Xè½´æ—¥æœŸæ ‡ç­¾ï¼ˆåªæ˜¾ç¤ºéƒ¨åˆ†ï¼‰
            ctx.textAlign = 'center';
            for (let i = 0; i < data.length; i += Math.floor(data.length / 5)) {
                const x = padding + i * barWidth + barWidth / 2;
                const date = data[i].date.substring(5);  // MM-DD
                ctx.fillText(date, x, height - 5);
            }

            // 9. ç»˜åˆ¶å‚æ•°æç¤º
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`MA${params.ma_period || 30} | MA${params.retest_period || 5} | é‡èƒ½${params.volume_multiplier || 2}å€ | æŒæœ‰${params.hold_days || 5}å¤©`, padding, 15);

            // ä¿¡å·ç»Ÿè®¡
            ctx.fillText(`ä¹°å…¥ä¿¡å·: ${buySignals.length} ä¸ª | å–å‡ºä¿¡å·: ${sellSignals.length} ä¸ª`, padding, height - volumeHeight - 10);
        }

        // ç­–ç•¥åˆ‡æ¢åé‡æ–°ç»˜åˆ¶å›¾è¡¨ï¼ˆå¢å¼ºåŸæœ‰å‡½æ•°ï¼‰
        const _originalSwitchStrategy = switchStrategy;
        switchStrategy = async function() {
            await _originalSwitchStrategy();
            setTimeout(() => {
                if (typeof drawKLineChart === 'function') {
                    drawKLineChart();
                }
            }, 500);
        };
    </script>
</body>
</html>
